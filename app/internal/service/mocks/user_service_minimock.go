// Code generated by http://github.com/gojuno/minimock (v3.3.14). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/bmstu-itstech/contest-auth/internal/service.UserService -o user_service_minimock.go -n UserServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/bmstu-itstech/contest-auth/internal/model"
	"github.com/gojuno/minimock/v3"
)

// UserServiceMock implements service.UserService
type UserServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetAccessToken          func(ctx context.Context, params model.GetAccessTokenParams) (resp model.GetAccessTokenResponse, err error)
	inspectFuncGetAccessToken   func(ctx context.Context, params model.GetAccessTokenParams)
	afterGetAccessTokenCounter  uint64
	beforeGetAccessTokenCounter uint64
	GetAccessTokenMock          mUserServiceMockGetAccessToken

	funcGetRefreshToken          func(ctx context.Context, params model.GetRefreshTokenParams) (resp model.GetRefreshTokenResponse, err error)
	inspectFuncGetRefreshToken   func(ctx context.Context, params model.GetRefreshTokenParams)
	afterGetRefreshTokenCounter  uint64
	beforeGetRefreshTokenCounter uint64
	GetRefreshTokenMock          mUserServiceMockGetRefreshToken

	funcLogin          func(ctx context.Context, params model.LoginParams) (resp model.LoginResponse, err error)
	inspectFuncLogin   func(ctx context.Context, params model.LoginParams)
	afterLoginCounter  uint64
	beforeLoginCounter uint64
	LoginMock          mUserServiceMockLogin

	funcLogout          func(ctx context.Context, params model.LogoutParams) (resp model.LogoutResponse, err error)
	inspectFuncLogout   func(ctx context.Context, params model.LogoutParams)
	afterLogoutCounter  uint64
	beforeLogoutCounter uint64
	LogoutMock          mUserServiceMockLogout

	funcRegistration          func(ctx context.Context, params model.RegistrationParams) (resp model.RegistrationResponse, err error)
	inspectFuncRegistration   func(ctx context.Context, params model.RegistrationParams)
	afterRegistrationCounter  uint64
	beforeRegistrationCounter uint64
	RegistrationMock          mUserServiceMockRegistration
}

// NewUserServiceMock returns a mock for service.UserService
func NewUserServiceMock(t minimock.Tester) *UserServiceMock {
	m := &UserServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetAccessTokenMock = mUserServiceMockGetAccessToken{mock: m}
	m.GetAccessTokenMock.callArgs = []*UserServiceMockGetAccessTokenParams{}

	m.GetRefreshTokenMock = mUserServiceMockGetRefreshToken{mock: m}
	m.GetRefreshTokenMock.callArgs = []*UserServiceMockGetRefreshTokenParams{}

	m.LoginMock = mUserServiceMockLogin{mock: m}
	m.LoginMock.callArgs = []*UserServiceMockLoginParams{}

	m.LogoutMock = mUserServiceMockLogout{mock: m}
	m.LogoutMock.callArgs = []*UserServiceMockLogoutParams{}

	m.RegistrationMock = mUserServiceMockRegistration{mock: m}
	m.RegistrationMock.callArgs = []*UserServiceMockRegistrationParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mUserServiceMockGetAccessToken struct {
	optional           bool
	mock               *UserServiceMock
	defaultExpectation *UserServiceMockGetAccessTokenExpectation
	expectations       []*UserServiceMockGetAccessTokenExpectation

	callArgs []*UserServiceMockGetAccessTokenParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UserServiceMockGetAccessTokenExpectation specifies expectation struct of the UserService.GetAccessToken
type UserServiceMockGetAccessTokenExpectation struct {
	mock      *UserServiceMock
	params    *UserServiceMockGetAccessTokenParams
	paramPtrs *UserServiceMockGetAccessTokenParamPtrs
	results   *UserServiceMockGetAccessTokenResults
	Counter   uint64
}

// UserServiceMockGetAccessTokenParams contains parameters of the UserService.GetAccessToken
type UserServiceMockGetAccessTokenParams struct {
	ctx    context.Context
	params model.GetAccessTokenParams
}

// UserServiceMockGetAccessTokenParamPtrs contains pointers to parameters of the UserService.GetAccessToken
type UserServiceMockGetAccessTokenParamPtrs struct {
	ctx    *context.Context
	params *model.GetAccessTokenParams
}

// UserServiceMockGetAccessTokenResults contains results of the UserService.GetAccessToken
type UserServiceMockGetAccessTokenResults struct {
	resp model.GetAccessTokenResponse
	err  error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetAccessToken *mUserServiceMockGetAccessToken) Optional() *mUserServiceMockGetAccessToken {
	mmGetAccessToken.optional = true
	return mmGetAccessToken
}

// Expect sets up expected params for UserService.GetAccessToken
func (mmGetAccessToken *mUserServiceMockGetAccessToken) Expect(ctx context.Context, params model.GetAccessTokenParams) *mUserServiceMockGetAccessToken {
	if mmGetAccessToken.mock.funcGetAccessToken != nil {
		mmGetAccessToken.mock.t.Fatalf("UserServiceMock.GetAccessToken mock is already set by Set")
	}

	if mmGetAccessToken.defaultExpectation == nil {
		mmGetAccessToken.defaultExpectation = &UserServiceMockGetAccessTokenExpectation{}
	}

	if mmGetAccessToken.defaultExpectation.paramPtrs != nil {
		mmGetAccessToken.mock.t.Fatalf("UserServiceMock.GetAccessToken mock is already set by ExpectParams functions")
	}

	mmGetAccessToken.defaultExpectation.params = &UserServiceMockGetAccessTokenParams{ctx, params}
	for _, e := range mmGetAccessToken.expectations {
		if minimock.Equal(e.params, mmGetAccessToken.defaultExpectation.params) {
			mmGetAccessToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAccessToken.defaultExpectation.params)
		}
	}

	return mmGetAccessToken
}

// ExpectCtxParam1 sets up expected param ctx for UserService.GetAccessToken
func (mmGetAccessToken *mUserServiceMockGetAccessToken) ExpectCtxParam1(ctx context.Context) *mUserServiceMockGetAccessToken {
	if mmGetAccessToken.mock.funcGetAccessToken != nil {
		mmGetAccessToken.mock.t.Fatalf("UserServiceMock.GetAccessToken mock is already set by Set")
	}

	if mmGetAccessToken.defaultExpectation == nil {
		mmGetAccessToken.defaultExpectation = &UserServiceMockGetAccessTokenExpectation{}
	}

	if mmGetAccessToken.defaultExpectation.params != nil {
		mmGetAccessToken.mock.t.Fatalf("UserServiceMock.GetAccessToken mock is already set by Expect")
	}

	if mmGetAccessToken.defaultExpectation.paramPtrs == nil {
		mmGetAccessToken.defaultExpectation.paramPtrs = &UserServiceMockGetAccessTokenParamPtrs{}
	}
	mmGetAccessToken.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetAccessToken
}

// ExpectParamsParam2 sets up expected param params for UserService.GetAccessToken
func (mmGetAccessToken *mUserServiceMockGetAccessToken) ExpectParamsParam2(params model.GetAccessTokenParams) *mUserServiceMockGetAccessToken {
	if mmGetAccessToken.mock.funcGetAccessToken != nil {
		mmGetAccessToken.mock.t.Fatalf("UserServiceMock.GetAccessToken mock is already set by Set")
	}

	if mmGetAccessToken.defaultExpectation == nil {
		mmGetAccessToken.defaultExpectation = &UserServiceMockGetAccessTokenExpectation{}
	}

	if mmGetAccessToken.defaultExpectation.params != nil {
		mmGetAccessToken.mock.t.Fatalf("UserServiceMock.GetAccessToken mock is already set by Expect")
	}

	if mmGetAccessToken.defaultExpectation.paramPtrs == nil {
		mmGetAccessToken.defaultExpectation.paramPtrs = &UserServiceMockGetAccessTokenParamPtrs{}
	}
	mmGetAccessToken.defaultExpectation.paramPtrs.params = &params

	return mmGetAccessToken
}

// Inspect accepts an inspector function that has same arguments as the UserService.GetAccessToken
func (mmGetAccessToken *mUserServiceMockGetAccessToken) Inspect(f func(ctx context.Context, params model.GetAccessTokenParams)) *mUserServiceMockGetAccessToken {
	if mmGetAccessToken.mock.inspectFuncGetAccessToken != nil {
		mmGetAccessToken.mock.t.Fatalf("Inspect function is already set for UserServiceMock.GetAccessToken")
	}

	mmGetAccessToken.mock.inspectFuncGetAccessToken = f

	return mmGetAccessToken
}

// Return sets up results that will be returned by UserService.GetAccessToken
func (mmGetAccessToken *mUserServiceMockGetAccessToken) Return(resp model.GetAccessTokenResponse, err error) *UserServiceMock {
	if mmGetAccessToken.mock.funcGetAccessToken != nil {
		mmGetAccessToken.mock.t.Fatalf("UserServiceMock.GetAccessToken mock is already set by Set")
	}

	if mmGetAccessToken.defaultExpectation == nil {
		mmGetAccessToken.defaultExpectation = &UserServiceMockGetAccessTokenExpectation{mock: mmGetAccessToken.mock}
	}
	mmGetAccessToken.defaultExpectation.results = &UserServiceMockGetAccessTokenResults{resp, err}
	return mmGetAccessToken.mock
}

// Set uses given function f to mock the UserService.GetAccessToken method
func (mmGetAccessToken *mUserServiceMockGetAccessToken) Set(f func(ctx context.Context, params model.GetAccessTokenParams) (resp model.GetAccessTokenResponse, err error)) *UserServiceMock {
	if mmGetAccessToken.defaultExpectation != nil {
		mmGetAccessToken.mock.t.Fatalf("Default expectation is already set for the UserService.GetAccessToken method")
	}

	if len(mmGetAccessToken.expectations) > 0 {
		mmGetAccessToken.mock.t.Fatalf("Some expectations are already set for the UserService.GetAccessToken method")
	}

	mmGetAccessToken.mock.funcGetAccessToken = f
	return mmGetAccessToken.mock
}

// When sets expectation for the UserService.GetAccessToken which will trigger the result defined by the following
// Then helper
func (mmGetAccessToken *mUserServiceMockGetAccessToken) When(ctx context.Context, params model.GetAccessTokenParams) *UserServiceMockGetAccessTokenExpectation {
	if mmGetAccessToken.mock.funcGetAccessToken != nil {
		mmGetAccessToken.mock.t.Fatalf("UserServiceMock.GetAccessToken mock is already set by Set")
	}

	expectation := &UserServiceMockGetAccessTokenExpectation{
		mock:   mmGetAccessToken.mock,
		params: &UserServiceMockGetAccessTokenParams{ctx, params},
	}
	mmGetAccessToken.expectations = append(mmGetAccessToken.expectations, expectation)
	return expectation
}

// Then sets up UserService.GetAccessToken return parameters for the expectation previously defined by the When method
func (e *UserServiceMockGetAccessTokenExpectation) Then(resp model.GetAccessTokenResponse, err error) *UserServiceMock {
	e.results = &UserServiceMockGetAccessTokenResults{resp, err}
	return e.mock
}

// Times sets number of times UserService.GetAccessToken should be invoked
func (mmGetAccessToken *mUserServiceMockGetAccessToken) Times(n uint64) *mUserServiceMockGetAccessToken {
	if n == 0 {
		mmGetAccessToken.mock.t.Fatalf("Times of UserServiceMock.GetAccessToken mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetAccessToken.expectedInvocations, n)
	return mmGetAccessToken
}

func (mmGetAccessToken *mUserServiceMockGetAccessToken) invocationsDone() bool {
	if len(mmGetAccessToken.expectations) == 0 && mmGetAccessToken.defaultExpectation == nil && mmGetAccessToken.mock.funcGetAccessToken == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetAccessToken.mock.afterGetAccessTokenCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetAccessToken.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetAccessToken implements service.UserService
func (mmGetAccessToken *UserServiceMock) GetAccessToken(ctx context.Context, params model.GetAccessTokenParams) (resp model.GetAccessTokenResponse, err error) {
	mm_atomic.AddUint64(&mmGetAccessToken.beforeGetAccessTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAccessToken.afterGetAccessTokenCounter, 1)

	if mmGetAccessToken.inspectFuncGetAccessToken != nil {
		mmGetAccessToken.inspectFuncGetAccessToken(ctx, params)
	}

	mm_params := UserServiceMockGetAccessTokenParams{ctx, params}

	// Record call args
	mmGetAccessToken.GetAccessTokenMock.mutex.Lock()
	mmGetAccessToken.GetAccessTokenMock.callArgs = append(mmGetAccessToken.GetAccessTokenMock.callArgs, &mm_params)
	mmGetAccessToken.GetAccessTokenMock.mutex.Unlock()

	for _, e := range mmGetAccessToken.GetAccessTokenMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.resp, e.results.err
		}
	}

	if mmGetAccessToken.GetAccessTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAccessToken.GetAccessTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAccessToken.GetAccessTokenMock.defaultExpectation.params
		mm_want_ptrs := mmGetAccessToken.GetAccessTokenMock.defaultExpectation.paramPtrs

		mm_got := UserServiceMockGetAccessTokenParams{ctx, params}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetAccessToken.t.Errorf("UserServiceMock.GetAccessToken got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.params != nil && !minimock.Equal(*mm_want_ptrs.params, mm_got.params) {
				mmGetAccessToken.t.Errorf("UserServiceMock.GetAccessToken got unexpected parameter params, want: %#v, got: %#v%s\n", *mm_want_ptrs.params, mm_got.params, minimock.Diff(*mm_want_ptrs.params, mm_got.params))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAccessToken.t.Errorf("UserServiceMock.GetAccessToken got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAccessToken.GetAccessTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAccessToken.t.Fatal("No results are set for the UserServiceMock.GetAccessToken")
		}
		return (*mm_results).resp, (*mm_results).err
	}
	if mmGetAccessToken.funcGetAccessToken != nil {
		return mmGetAccessToken.funcGetAccessToken(ctx, params)
	}
	mmGetAccessToken.t.Fatalf("Unexpected call to UserServiceMock.GetAccessToken. %v %v", ctx, params)
	return
}

// GetAccessTokenAfterCounter returns a count of finished UserServiceMock.GetAccessToken invocations
func (mmGetAccessToken *UserServiceMock) GetAccessTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAccessToken.afterGetAccessTokenCounter)
}

// GetAccessTokenBeforeCounter returns a count of UserServiceMock.GetAccessToken invocations
func (mmGetAccessToken *UserServiceMock) GetAccessTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAccessToken.beforeGetAccessTokenCounter)
}

// Calls returns a list of arguments used in each call to UserServiceMock.GetAccessToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAccessToken *mUserServiceMockGetAccessToken) Calls() []*UserServiceMockGetAccessTokenParams {
	mmGetAccessToken.mutex.RLock()

	argCopy := make([]*UserServiceMockGetAccessTokenParams, len(mmGetAccessToken.callArgs))
	copy(argCopy, mmGetAccessToken.callArgs)

	mmGetAccessToken.mutex.RUnlock()

	return argCopy
}

// MinimockGetAccessTokenDone returns true if the count of the GetAccessToken invocations corresponds
// the number of defined expectations
func (m *UserServiceMock) MinimockGetAccessTokenDone() bool {
	if m.GetAccessTokenMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetAccessTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetAccessTokenMock.invocationsDone()
}

// MinimockGetAccessTokenInspect logs each unmet expectation
func (m *UserServiceMock) MinimockGetAccessTokenInspect() {
	for _, e := range m.GetAccessTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserServiceMock.GetAccessToken with params: %#v", *e.params)
		}
	}

	afterGetAccessTokenCounter := mm_atomic.LoadUint64(&m.afterGetAccessTokenCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetAccessTokenMock.defaultExpectation != nil && afterGetAccessTokenCounter < 1 {
		if m.GetAccessTokenMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserServiceMock.GetAccessToken")
		} else {
			m.t.Errorf("Expected call to UserServiceMock.GetAccessToken with params: %#v", *m.GetAccessTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAccessToken != nil && afterGetAccessTokenCounter < 1 {
		m.t.Error("Expected call to UserServiceMock.GetAccessToken")
	}

	if !m.GetAccessTokenMock.invocationsDone() && afterGetAccessTokenCounter > 0 {
		m.t.Errorf("Expected %d calls to UserServiceMock.GetAccessToken but found %d calls",
			mm_atomic.LoadUint64(&m.GetAccessTokenMock.expectedInvocations), afterGetAccessTokenCounter)
	}
}

type mUserServiceMockGetRefreshToken struct {
	optional           bool
	mock               *UserServiceMock
	defaultExpectation *UserServiceMockGetRefreshTokenExpectation
	expectations       []*UserServiceMockGetRefreshTokenExpectation

	callArgs []*UserServiceMockGetRefreshTokenParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UserServiceMockGetRefreshTokenExpectation specifies expectation struct of the UserService.GetRefreshToken
type UserServiceMockGetRefreshTokenExpectation struct {
	mock      *UserServiceMock
	params    *UserServiceMockGetRefreshTokenParams
	paramPtrs *UserServiceMockGetRefreshTokenParamPtrs
	results   *UserServiceMockGetRefreshTokenResults
	Counter   uint64
}

// UserServiceMockGetRefreshTokenParams contains parameters of the UserService.GetRefreshToken
type UserServiceMockGetRefreshTokenParams struct {
	ctx    context.Context
	params model.GetRefreshTokenParams
}

// UserServiceMockGetRefreshTokenParamPtrs contains pointers to parameters of the UserService.GetRefreshToken
type UserServiceMockGetRefreshTokenParamPtrs struct {
	ctx    *context.Context
	params *model.GetRefreshTokenParams
}

// UserServiceMockGetRefreshTokenResults contains results of the UserService.GetRefreshToken
type UserServiceMockGetRefreshTokenResults struct {
	resp model.GetRefreshTokenResponse
	err  error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetRefreshToken *mUserServiceMockGetRefreshToken) Optional() *mUserServiceMockGetRefreshToken {
	mmGetRefreshToken.optional = true
	return mmGetRefreshToken
}

// Expect sets up expected params for UserService.GetRefreshToken
func (mmGetRefreshToken *mUserServiceMockGetRefreshToken) Expect(ctx context.Context, params model.GetRefreshTokenParams) *mUserServiceMockGetRefreshToken {
	if mmGetRefreshToken.mock.funcGetRefreshToken != nil {
		mmGetRefreshToken.mock.t.Fatalf("UserServiceMock.GetRefreshToken mock is already set by Set")
	}

	if mmGetRefreshToken.defaultExpectation == nil {
		mmGetRefreshToken.defaultExpectation = &UserServiceMockGetRefreshTokenExpectation{}
	}

	if mmGetRefreshToken.defaultExpectation.paramPtrs != nil {
		mmGetRefreshToken.mock.t.Fatalf("UserServiceMock.GetRefreshToken mock is already set by ExpectParams functions")
	}

	mmGetRefreshToken.defaultExpectation.params = &UserServiceMockGetRefreshTokenParams{ctx, params}
	for _, e := range mmGetRefreshToken.expectations {
		if minimock.Equal(e.params, mmGetRefreshToken.defaultExpectation.params) {
			mmGetRefreshToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRefreshToken.defaultExpectation.params)
		}
	}

	return mmGetRefreshToken
}

// ExpectCtxParam1 sets up expected param ctx for UserService.GetRefreshToken
func (mmGetRefreshToken *mUserServiceMockGetRefreshToken) ExpectCtxParam1(ctx context.Context) *mUserServiceMockGetRefreshToken {
	if mmGetRefreshToken.mock.funcGetRefreshToken != nil {
		mmGetRefreshToken.mock.t.Fatalf("UserServiceMock.GetRefreshToken mock is already set by Set")
	}

	if mmGetRefreshToken.defaultExpectation == nil {
		mmGetRefreshToken.defaultExpectation = &UserServiceMockGetRefreshTokenExpectation{}
	}

	if mmGetRefreshToken.defaultExpectation.params != nil {
		mmGetRefreshToken.mock.t.Fatalf("UserServiceMock.GetRefreshToken mock is already set by Expect")
	}

	if mmGetRefreshToken.defaultExpectation.paramPtrs == nil {
		mmGetRefreshToken.defaultExpectation.paramPtrs = &UserServiceMockGetRefreshTokenParamPtrs{}
	}
	mmGetRefreshToken.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetRefreshToken
}

// ExpectParamsParam2 sets up expected param params for UserService.GetRefreshToken
func (mmGetRefreshToken *mUserServiceMockGetRefreshToken) ExpectParamsParam2(params model.GetRefreshTokenParams) *mUserServiceMockGetRefreshToken {
	if mmGetRefreshToken.mock.funcGetRefreshToken != nil {
		mmGetRefreshToken.mock.t.Fatalf("UserServiceMock.GetRefreshToken mock is already set by Set")
	}

	if mmGetRefreshToken.defaultExpectation == nil {
		mmGetRefreshToken.defaultExpectation = &UserServiceMockGetRefreshTokenExpectation{}
	}

	if mmGetRefreshToken.defaultExpectation.params != nil {
		mmGetRefreshToken.mock.t.Fatalf("UserServiceMock.GetRefreshToken mock is already set by Expect")
	}

	if mmGetRefreshToken.defaultExpectation.paramPtrs == nil {
		mmGetRefreshToken.defaultExpectation.paramPtrs = &UserServiceMockGetRefreshTokenParamPtrs{}
	}
	mmGetRefreshToken.defaultExpectation.paramPtrs.params = &params

	return mmGetRefreshToken
}

// Inspect accepts an inspector function that has same arguments as the UserService.GetRefreshToken
func (mmGetRefreshToken *mUserServiceMockGetRefreshToken) Inspect(f func(ctx context.Context, params model.GetRefreshTokenParams)) *mUserServiceMockGetRefreshToken {
	if mmGetRefreshToken.mock.inspectFuncGetRefreshToken != nil {
		mmGetRefreshToken.mock.t.Fatalf("Inspect function is already set for UserServiceMock.GetRefreshToken")
	}

	mmGetRefreshToken.mock.inspectFuncGetRefreshToken = f

	return mmGetRefreshToken
}

// Return sets up results that will be returned by UserService.GetRefreshToken
func (mmGetRefreshToken *mUserServiceMockGetRefreshToken) Return(resp model.GetRefreshTokenResponse, err error) *UserServiceMock {
	if mmGetRefreshToken.mock.funcGetRefreshToken != nil {
		mmGetRefreshToken.mock.t.Fatalf("UserServiceMock.GetRefreshToken mock is already set by Set")
	}

	if mmGetRefreshToken.defaultExpectation == nil {
		mmGetRefreshToken.defaultExpectation = &UserServiceMockGetRefreshTokenExpectation{mock: mmGetRefreshToken.mock}
	}
	mmGetRefreshToken.defaultExpectation.results = &UserServiceMockGetRefreshTokenResults{resp, err}
	return mmGetRefreshToken.mock
}

// Set uses given function f to mock the UserService.GetRefreshToken method
func (mmGetRefreshToken *mUserServiceMockGetRefreshToken) Set(f func(ctx context.Context, params model.GetRefreshTokenParams) (resp model.GetRefreshTokenResponse, err error)) *UserServiceMock {
	if mmGetRefreshToken.defaultExpectation != nil {
		mmGetRefreshToken.mock.t.Fatalf("Default expectation is already set for the UserService.GetRefreshToken method")
	}

	if len(mmGetRefreshToken.expectations) > 0 {
		mmGetRefreshToken.mock.t.Fatalf("Some expectations are already set for the UserService.GetRefreshToken method")
	}

	mmGetRefreshToken.mock.funcGetRefreshToken = f
	return mmGetRefreshToken.mock
}

// When sets expectation for the UserService.GetRefreshToken which will trigger the result defined by the following
// Then helper
func (mmGetRefreshToken *mUserServiceMockGetRefreshToken) When(ctx context.Context, params model.GetRefreshTokenParams) *UserServiceMockGetRefreshTokenExpectation {
	if mmGetRefreshToken.mock.funcGetRefreshToken != nil {
		mmGetRefreshToken.mock.t.Fatalf("UserServiceMock.GetRefreshToken mock is already set by Set")
	}

	expectation := &UserServiceMockGetRefreshTokenExpectation{
		mock:   mmGetRefreshToken.mock,
		params: &UserServiceMockGetRefreshTokenParams{ctx, params},
	}
	mmGetRefreshToken.expectations = append(mmGetRefreshToken.expectations, expectation)
	return expectation
}

// Then sets up UserService.GetRefreshToken return parameters for the expectation previously defined by the When method
func (e *UserServiceMockGetRefreshTokenExpectation) Then(resp model.GetRefreshTokenResponse, err error) *UserServiceMock {
	e.results = &UserServiceMockGetRefreshTokenResults{resp, err}
	return e.mock
}

// Times sets number of times UserService.GetRefreshToken should be invoked
func (mmGetRefreshToken *mUserServiceMockGetRefreshToken) Times(n uint64) *mUserServiceMockGetRefreshToken {
	if n == 0 {
		mmGetRefreshToken.mock.t.Fatalf("Times of UserServiceMock.GetRefreshToken mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetRefreshToken.expectedInvocations, n)
	return mmGetRefreshToken
}

func (mmGetRefreshToken *mUserServiceMockGetRefreshToken) invocationsDone() bool {
	if len(mmGetRefreshToken.expectations) == 0 && mmGetRefreshToken.defaultExpectation == nil && mmGetRefreshToken.mock.funcGetRefreshToken == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetRefreshToken.mock.afterGetRefreshTokenCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetRefreshToken.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetRefreshToken implements service.UserService
func (mmGetRefreshToken *UserServiceMock) GetRefreshToken(ctx context.Context, params model.GetRefreshTokenParams) (resp model.GetRefreshTokenResponse, err error) {
	mm_atomic.AddUint64(&mmGetRefreshToken.beforeGetRefreshTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRefreshToken.afterGetRefreshTokenCounter, 1)

	if mmGetRefreshToken.inspectFuncGetRefreshToken != nil {
		mmGetRefreshToken.inspectFuncGetRefreshToken(ctx, params)
	}

	mm_params := UserServiceMockGetRefreshTokenParams{ctx, params}

	// Record call args
	mmGetRefreshToken.GetRefreshTokenMock.mutex.Lock()
	mmGetRefreshToken.GetRefreshTokenMock.callArgs = append(mmGetRefreshToken.GetRefreshTokenMock.callArgs, &mm_params)
	mmGetRefreshToken.GetRefreshTokenMock.mutex.Unlock()

	for _, e := range mmGetRefreshToken.GetRefreshTokenMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.resp, e.results.err
		}
	}

	if mmGetRefreshToken.GetRefreshTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRefreshToken.GetRefreshTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRefreshToken.GetRefreshTokenMock.defaultExpectation.params
		mm_want_ptrs := mmGetRefreshToken.GetRefreshTokenMock.defaultExpectation.paramPtrs

		mm_got := UserServiceMockGetRefreshTokenParams{ctx, params}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetRefreshToken.t.Errorf("UserServiceMock.GetRefreshToken got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.params != nil && !minimock.Equal(*mm_want_ptrs.params, mm_got.params) {
				mmGetRefreshToken.t.Errorf("UserServiceMock.GetRefreshToken got unexpected parameter params, want: %#v, got: %#v%s\n", *mm_want_ptrs.params, mm_got.params, minimock.Diff(*mm_want_ptrs.params, mm_got.params))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRefreshToken.t.Errorf("UserServiceMock.GetRefreshToken got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRefreshToken.GetRefreshTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRefreshToken.t.Fatal("No results are set for the UserServiceMock.GetRefreshToken")
		}
		return (*mm_results).resp, (*mm_results).err
	}
	if mmGetRefreshToken.funcGetRefreshToken != nil {
		return mmGetRefreshToken.funcGetRefreshToken(ctx, params)
	}
	mmGetRefreshToken.t.Fatalf("Unexpected call to UserServiceMock.GetRefreshToken. %v %v", ctx, params)
	return
}

// GetRefreshTokenAfterCounter returns a count of finished UserServiceMock.GetRefreshToken invocations
func (mmGetRefreshToken *UserServiceMock) GetRefreshTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRefreshToken.afterGetRefreshTokenCounter)
}

// GetRefreshTokenBeforeCounter returns a count of UserServiceMock.GetRefreshToken invocations
func (mmGetRefreshToken *UserServiceMock) GetRefreshTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRefreshToken.beforeGetRefreshTokenCounter)
}

// Calls returns a list of arguments used in each call to UserServiceMock.GetRefreshToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRefreshToken *mUserServiceMockGetRefreshToken) Calls() []*UserServiceMockGetRefreshTokenParams {
	mmGetRefreshToken.mutex.RLock()

	argCopy := make([]*UserServiceMockGetRefreshTokenParams, len(mmGetRefreshToken.callArgs))
	copy(argCopy, mmGetRefreshToken.callArgs)

	mmGetRefreshToken.mutex.RUnlock()

	return argCopy
}

// MinimockGetRefreshTokenDone returns true if the count of the GetRefreshToken invocations corresponds
// the number of defined expectations
func (m *UserServiceMock) MinimockGetRefreshTokenDone() bool {
	if m.GetRefreshTokenMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetRefreshTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetRefreshTokenMock.invocationsDone()
}

// MinimockGetRefreshTokenInspect logs each unmet expectation
func (m *UserServiceMock) MinimockGetRefreshTokenInspect() {
	for _, e := range m.GetRefreshTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserServiceMock.GetRefreshToken with params: %#v", *e.params)
		}
	}

	afterGetRefreshTokenCounter := mm_atomic.LoadUint64(&m.afterGetRefreshTokenCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetRefreshTokenMock.defaultExpectation != nil && afterGetRefreshTokenCounter < 1 {
		if m.GetRefreshTokenMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserServiceMock.GetRefreshToken")
		} else {
			m.t.Errorf("Expected call to UserServiceMock.GetRefreshToken with params: %#v", *m.GetRefreshTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRefreshToken != nil && afterGetRefreshTokenCounter < 1 {
		m.t.Error("Expected call to UserServiceMock.GetRefreshToken")
	}

	if !m.GetRefreshTokenMock.invocationsDone() && afterGetRefreshTokenCounter > 0 {
		m.t.Errorf("Expected %d calls to UserServiceMock.GetRefreshToken but found %d calls",
			mm_atomic.LoadUint64(&m.GetRefreshTokenMock.expectedInvocations), afterGetRefreshTokenCounter)
	}
}

type mUserServiceMockLogin struct {
	optional           bool
	mock               *UserServiceMock
	defaultExpectation *UserServiceMockLoginExpectation
	expectations       []*UserServiceMockLoginExpectation

	callArgs []*UserServiceMockLoginParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UserServiceMockLoginExpectation specifies expectation struct of the UserService.Login
type UserServiceMockLoginExpectation struct {
	mock      *UserServiceMock
	params    *UserServiceMockLoginParams
	paramPtrs *UserServiceMockLoginParamPtrs
	results   *UserServiceMockLoginResults
	Counter   uint64
}

// UserServiceMockLoginParams contains parameters of the UserService.Login
type UserServiceMockLoginParams struct {
	ctx    context.Context
	params model.LoginParams
}

// UserServiceMockLoginParamPtrs contains pointers to parameters of the UserService.Login
type UserServiceMockLoginParamPtrs struct {
	ctx    *context.Context
	params *model.LoginParams
}

// UserServiceMockLoginResults contains results of the UserService.Login
type UserServiceMockLoginResults struct {
	resp model.LoginResponse
	err  error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLogin *mUserServiceMockLogin) Optional() *mUserServiceMockLogin {
	mmLogin.optional = true
	return mmLogin
}

// Expect sets up expected params for UserService.Login
func (mmLogin *mUserServiceMockLogin) Expect(ctx context.Context, params model.LoginParams) *mUserServiceMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("UserServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &UserServiceMockLoginExpectation{}
	}

	if mmLogin.defaultExpectation.paramPtrs != nil {
		mmLogin.mock.t.Fatalf("UserServiceMock.Login mock is already set by ExpectParams functions")
	}

	mmLogin.defaultExpectation.params = &UserServiceMockLoginParams{ctx, params}
	for _, e := range mmLogin.expectations {
		if minimock.Equal(e.params, mmLogin.defaultExpectation.params) {
			mmLogin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLogin.defaultExpectation.params)
		}
	}

	return mmLogin
}

// ExpectCtxParam1 sets up expected param ctx for UserService.Login
func (mmLogin *mUserServiceMockLogin) ExpectCtxParam1(ctx context.Context) *mUserServiceMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("UserServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &UserServiceMockLoginExpectation{}
	}

	if mmLogin.defaultExpectation.params != nil {
		mmLogin.mock.t.Fatalf("UserServiceMock.Login mock is already set by Expect")
	}

	if mmLogin.defaultExpectation.paramPtrs == nil {
		mmLogin.defaultExpectation.paramPtrs = &UserServiceMockLoginParamPtrs{}
	}
	mmLogin.defaultExpectation.paramPtrs.ctx = &ctx

	return mmLogin
}

// ExpectParamsParam2 sets up expected param params for UserService.Login
func (mmLogin *mUserServiceMockLogin) ExpectParamsParam2(params model.LoginParams) *mUserServiceMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("UserServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &UserServiceMockLoginExpectation{}
	}

	if mmLogin.defaultExpectation.params != nil {
		mmLogin.mock.t.Fatalf("UserServiceMock.Login mock is already set by Expect")
	}

	if mmLogin.defaultExpectation.paramPtrs == nil {
		mmLogin.defaultExpectation.paramPtrs = &UserServiceMockLoginParamPtrs{}
	}
	mmLogin.defaultExpectation.paramPtrs.params = &params

	return mmLogin
}

// Inspect accepts an inspector function that has same arguments as the UserService.Login
func (mmLogin *mUserServiceMockLogin) Inspect(f func(ctx context.Context, params model.LoginParams)) *mUserServiceMockLogin {
	if mmLogin.mock.inspectFuncLogin != nil {
		mmLogin.mock.t.Fatalf("Inspect function is already set for UserServiceMock.Login")
	}

	mmLogin.mock.inspectFuncLogin = f

	return mmLogin
}

// Return sets up results that will be returned by UserService.Login
func (mmLogin *mUserServiceMockLogin) Return(resp model.LoginResponse, err error) *UserServiceMock {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("UserServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &UserServiceMockLoginExpectation{mock: mmLogin.mock}
	}
	mmLogin.defaultExpectation.results = &UserServiceMockLoginResults{resp, err}
	return mmLogin.mock
}

// Set uses given function f to mock the UserService.Login method
func (mmLogin *mUserServiceMockLogin) Set(f func(ctx context.Context, params model.LoginParams) (resp model.LoginResponse, err error)) *UserServiceMock {
	if mmLogin.defaultExpectation != nil {
		mmLogin.mock.t.Fatalf("Default expectation is already set for the UserService.Login method")
	}

	if len(mmLogin.expectations) > 0 {
		mmLogin.mock.t.Fatalf("Some expectations are already set for the UserService.Login method")
	}

	mmLogin.mock.funcLogin = f
	return mmLogin.mock
}

// When sets expectation for the UserService.Login which will trigger the result defined by the following
// Then helper
func (mmLogin *mUserServiceMockLogin) When(ctx context.Context, params model.LoginParams) *UserServiceMockLoginExpectation {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("UserServiceMock.Login mock is already set by Set")
	}

	expectation := &UserServiceMockLoginExpectation{
		mock:   mmLogin.mock,
		params: &UserServiceMockLoginParams{ctx, params},
	}
	mmLogin.expectations = append(mmLogin.expectations, expectation)
	return expectation
}

// Then sets up UserService.Login return parameters for the expectation previously defined by the When method
func (e *UserServiceMockLoginExpectation) Then(resp model.LoginResponse, err error) *UserServiceMock {
	e.results = &UserServiceMockLoginResults{resp, err}
	return e.mock
}

// Times sets number of times UserService.Login should be invoked
func (mmLogin *mUserServiceMockLogin) Times(n uint64) *mUserServiceMockLogin {
	if n == 0 {
		mmLogin.mock.t.Fatalf("Times of UserServiceMock.Login mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLogin.expectedInvocations, n)
	return mmLogin
}

func (mmLogin *mUserServiceMockLogin) invocationsDone() bool {
	if len(mmLogin.expectations) == 0 && mmLogin.defaultExpectation == nil && mmLogin.mock.funcLogin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLogin.mock.afterLoginCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLogin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Login implements service.UserService
func (mmLogin *UserServiceMock) Login(ctx context.Context, params model.LoginParams) (resp model.LoginResponse, err error) {
	mm_atomic.AddUint64(&mmLogin.beforeLoginCounter, 1)
	defer mm_atomic.AddUint64(&mmLogin.afterLoginCounter, 1)

	if mmLogin.inspectFuncLogin != nil {
		mmLogin.inspectFuncLogin(ctx, params)
	}

	mm_params := UserServiceMockLoginParams{ctx, params}

	// Record call args
	mmLogin.LoginMock.mutex.Lock()
	mmLogin.LoginMock.callArgs = append(mmLogin.LoginMock.callArgs, &mm_params)
	mmLogin.LoginMock.mutex.Unlock()

	for _, e := range mmLogin.LoginMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.resp, e.results.err
		}
	}

	if mmLogin.LoginMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLogin.LoginMock.defaultExpectation.Counter, 1)
		mm_want := mmLogin.LoginMock.defaultExpectation.params
		mm_want_ptrs := mmLogin.LoginMock.defaultExpectation.paramPtrs

		mm_got := UserServiceMockLoginParams{ctx, params}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmLogin.t.Errorf("UserServiceMock.Login got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.params != nil && !minimock.Equal(*mm_want_ptrs.params, mm_got.params) {
				mmLogin.t.Errorf("UserServiceMock.Login got unexpected parameter params, want: %#v, got: %#v%s\n", *mm_want_ptrs.params, mm_got.params, minimock.Diff(*mm_want_ptrs.params, mm_got.params))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLogin.t.Errorf("UserServiceMock.Login got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLogin.LoginMock.defaultExpectation.results
		if mm_results == nil {
			mmLogin.t.Fatal("No results are set for the UserServiceMock.Login")
		}
		return (*mm_results).resp, (*mm_results).err
	}
	if mmLogin.funcLogin != nil {
		return mmLogin.funcLogin(ctx, params)
	}
	mmLogin.t.Fatalf("Unexpected call to UserServiceMock.Login. %v %v", ctx, params)
	return
}

// LoginAfterCounter returns a count of finished UserServiceMock.Login invocations
func (mmLogin *UserServiceMock) LoginAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogin.afterLoginCounter)
}

// LoginBeforeCounter returns a count of UserServiceMock.Login invocations
func (mmLogin *UserServiceMock) LoginBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogin.beforeLoginCounter)
}

// Calls returns a list of arguments used in each call to UserServiceMock.Login.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLogin *mUserServiceMockLogin) Calls() []*UserServiceMockLoginParams {
	mmLogin.mutex.RLock()

	argCopy := make([]*UserServiceMockLoginParams, len(mmLogin.callArgs))
	copy(argCopy, mmLogin.callArgs)

	mmLogin.mutex.RUnlock()

	return argCopy
}

// MinimockLoginDone returns true if the count of the Login invocations corresponds
// the number of defined expectations
func (m *UserServiceMock) MinimockLoginDone() bool {
	if m.LoginMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LoginMock.invocationsDone()
}

// MinimockLoginInspect logs each unmet expectation
func (m *UserServiceMock) MinimockLoginInspect() {
	for _, e := range m.LoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserServiceMock.Login with params: %#v", *e.params)
		}
	}

	afterLoginCounter := mm_atomic.LoadUint64(&m.afterLoginCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LoginMock.defaultExpectation != nil && afterLoginCounter < 1 {
		if m.LoginMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserServiceMock.Login")
		} else {
			m.t.Errorf("Expected call to UserServiceMock.Login with params: %#v", *m.LoginMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLogin != nil && afterLoginCounter < 1 {
		m.t.Error("Expected call to UserServiceMock.Login")
	}

	if !m.LoginMock.invocationsDone() && afterLoginCounter > 0 {
		m.t.Errorf("Expected %d calls to UserServiceMock.Login but found %d calls",
			mm_atomic.LoadUint64(&m.LoginMock.expectedInvocations), afterLoginCounter)
	}
}

type mUserServiceMockLogout struct {
	optional           bool
	mock               *UserServiceMock
	defaultExpectation *UserServiceMockLogoutExpectation
	expectations       []*UserServiceMockLogoutExpectation

	callArgs []*UserServiceMockLogoutParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UserServiceMockLogoutExpectation specifies expectation struct of the UserService.Logout
type UserServiceMockLogoutExpectation struct {
	mock      *UserServiceMock
	params    *UserServiceMockLogoutParams
	paramPtrs *UserServiceMockLogoutParamPtrs
	results   *UserServiceMockLogoutResults
	Counter   uint64
}

// UserServiceMockLogoutParams contains parameters of the UserService.Logout
type UserServiceMockLogoutParams struct {
	ctx    context.Context
	params model.LogoutParams
}

// UserServiceMockLogoutParamPtrs contains pointers to parameters of the UserService.Logout
type UserServiceMockLogoutParamPtrs struct {
	ctx    *context.Context
	params *model.LogoutParams
}

// UserServiceMockLogoutResults contains results of the UserService.Logout
type UserServiceMockLogoutResults struct {
	resp model.LogoutResponse
	err  error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLogout *mUserServiceMockLogout) Optional() *mUserServiceMockLogout {
	mmLogout.optional = true
	return mmLogout
}

// Expect sets up expected params for UserService.Logout
func (mmLogout *mUserServiceMockLogout) Expect(ctx context.Context, params model.LogoutParams) *mUserServiceMockLogout {
	if mmLogout.mock.funcLogout != nil {
		mmLogout.mock.t.Fatalf("UserServiceMock.Logout mock is already set by Set")
	}

	if mmLogout.defaultExpectation == nil {
		mmLogout.defaultExpectation = &UserServiceMockLogoutExpectation{}
	}

	if mmLogout.defaultExpectation.paramPtrs != nil {
		mmLogout.mock.t.Fatalf("UserServiceMock.Logout mock is already set by ExpectParams functions")
	}

	mmLogout.defaultExpectation.params = &UserServiceMockLogoutParams{ctx, params}
	for _, e := range mmLogout.expectations {
		if minimock.Equal(e.params, mmLogout.defaultExpectation.params) {
			mmLogout.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLogout.defaultExpectation.params)
		}
	}

	return mmLogout
}

// ExpectCtxParam1 sets up expected param ctx for UserService.Logout
func (mmLogout *mUserServiceMockLogout) ExpectCtxParam1(ctx context.Context) *mUserServiceMockLogout {
	if mmLogout.mock.funcLogout != nil {
		mmLogout.mock.t.Fatalf("UserServiceMock.Logout mock is already set by Set")
	}

	if mmLogout.defaultExpectation == nil {
		mmLogout.defaultExpectation = &UserServiceMockLogoutExpectation{}
	}

	if mmLogout.defaultExpectation.params != nil {
		mmLogout.mock.t.Fatalf("UserServiceMock.Logout mock is already set by Expect")
	}

	if mmLogout.defaultExpectation.paramPtrs == nil {
		mmLogout.defaultExpectation.paramPtrs = &UserServiceMockLogoutParamPtrs{}
	}
	mmLogout.defaultExpectation.paramPtrs.ctx = &ctx

	return mmLogout
}

// ExpectParamsParam2 sets up expected param params for UserService.Logout
func (mmLogout *mUserServiceMockLogout) ExpectParamsParam2(params model.LogoutParams) *mUserServiceMockLogout {
	if mmLogout.mock.funcLogout != nil {
		mmLogout.mock.t.Fatalf("UserServiceMock.Logout mock is already set by Set")
	}

	if mmLogout.defaultExpectation == nil {
		mmLogout.defaultExpectation = &UserServiceMockLogoutExpectation{}
	}

	if mmLogout.defaultExpectation.params != nil {
		mmLogout.mock.t.Fatalf("UserServiceMock.Logout mock is already set by Expect")
	}

	if mmLogout.defaultExpectation.paramPtrs == nil {
		mmLogout.defaultExpectation.paramPtrs = &UserServiceMockLogoutParamPtrs{}
	}
	mmLogout.defaultExpectation.paramPtrs.params = &params

	return mmLogout
}

// Inspect accepts an inspector function that has same arguments as the UserService.Logout
func (mmLogout *mUserServiceMockLogout) Inspect(f func(ctx context.Context, params model.LogoutParams)) *mUserServiceMockLogout {
	if mmLogout.mock.inspectFuncLogout != nil {
		mmLogout.mock.t.Fatalf("Inspect function is already set for UserServiceMock.Logout")
	}

	mmLogout.mock.inspectFuncLogout = f

	return mmLogout
}

// Return sets up results that will be returned by UserService.Logout
func (mmLogout *mUserServiceMockLogout) Return(resp model.LogoutResponse, err error) *UserServiceMock {
	if mmLogout.mock.funcLogout != nil {
		mmLogout.mock.t.Fatalf("UserServiceMock.Logout mock is already set by Set")
	}

	if mmLogout.defaultExpectation == nil {
		mmLogout.defaultExpectation = &UserServiceMockLogoutExpectation{mock: mmLogout.mock}
	}
	mmLogout.defaultExpectation.results = &UserServiceMockLogoutResults{resp, err}
	return mmLogout.mock
}

// Set uses given function f to mock the UserService.Logout method
func (mmLogout *mUserServiceMockLogout) Set(f func(ctx context.Context, params model.LogoutParams) (resp model.LogoutResponse, err error)) *UserServiceMock {
	if mmLogout.defaultExpectation != nil {
		mmLogout.mock.t.Fatalf("Default expectation is already set for the UserService.Logout method")
	}

	if len(mmLogout.expectations) > 0 {
		mmLogout.mock.t.Fatalf("Some expectations are already set for the UserService.Logout method")
	}

	mmLogout.mock.funcLogout = f
	return mmLogout.mock
}

// When sets expectation for the UserService.Logout which will trigger the result defined by the following
// Then helper
func (mmLogout *mUserServiceMockLogout) When(ctx context.Context, params model.LogoutParams) *UserServiceMockLogoutExpectation {
	if mmLogout.mock.funcLogout != nil {
		mmLogout.mock.t.Fatalf("UserServiceMock.Logout mock is already set by Set")
	}

	expectation := &UserServiceMockLogoutExpectation{
		mock:   mmLogout.mock,
		params: &UserServiceMockLogoutParams{ctx, params},
	}
	mmLogout.expectations = append(mmLogout.expectations, expectation)
	return expectation
}

// Then sets up UserService.Logout return parameters for the expectation previously defined by the When method
func (e *UserServiceMockLogoutExpectation) Then(resp model.LogoutResponse, err error) *UserServiceMock {
	e.results = &UserServiceMockLogoutResults{resp, err}
	return e.mock
}

// Times sets number of times UserService.Logout should be invoked
func (mmLogout *mUserServiceMockLogout) Times(n uint64) *mUserServiceMockLogout {
	if n == 0 {
		mmLogout.mock.t.Fatalf("Times of UserServiceMock.Logout mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLogout.expectedInvocations, n)
	return mmLogout
}

func (mmLogout *mUserServiceMockLogout) invocationsDone() bool {
	if len(mmLogout.expectations) == 0 && mmLogout.defaultExpectation == nil && mmLogout.mock.funcLogout == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLogout.mock.afterLogoutCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLogout.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Logout implements service.UserService
func (mmLogout *UserServiceMock) Logout(ctx context.Context, params model.LogoutParams) (resp model.LogoutResponse, err error) {
	mm_atomic.AddUint64(&mmLogout.beforeLogoutCounter, 1)
	defer mm_atomic.AddUint64(&mmLogout.afterLogoutCounter, 1)

	if mmLogout.inspectFuncLogout != nil {
		mmLogout.inspectFuncLogout(ctx, params)
	}

	mm_params := UserServiceMockLogoutParams{ctx, params}

	// Record call args
	mmLogout.LogoutMock.mutex.Lock()
	mmLogout.LogoutMock.callArgs = append(mmLogout.LogoutMock.callArgs, &mm_params)
	mmLogout.LogoutMock.mutex.Unlock()

	for _, e := range mmLogout.LogoutMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.resp, e.results.err
		}
	}

	if mmLogout.LogoutMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLogout.LogoutMock.defaultExpectation.Counter, 1)
		mm_want := mmLogout.LogoutMock.defaultExpectation.params
		mm_want_ptrs := mmLogout.LogoutMock.defaultExpectation.paramPtrs

		mm_got := UserServiceMockLogoutParams{ctx, params}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmLogout.t.Errorf("UserServiceMock.Logout got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.params != nil && !minimock.Equal(*mm_want_ptrs.params, mm_got.params) {
				mmLogout.t.Errorf("UserServiceMock.Logout got unexpected parameter params, want: %#v, got: %#v%s\n", *mm_want_ptrs.params, mm_got.params, minimock.Diff(*mm_want_ptrs.params, mm_got.params))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLogout.t.Errorf("UserServiceMock.Logout got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLogout.LogoutMock.defaultExpectation.results
		if mm_results == nil {
			mmLogout.t.Fatal("No results are set for the UserServiceMock.Logout")
		}
		return (*mm_results).resp, (*mm_results).err
	}
	if mmLogout.funcLogout != nil {
		return mmLogout.funcLogout(ctx, params)
	}
	mmLogout.t.Fatalf("Unexpected call to UserServiceMock.Logout. %v %v", ctx, params)
	return
}

// LogoutAfterCounter returns a count of finished UserServiceMock.Logout invocations
func (mmLogout *UserServiceMock) LogoutAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogout.afterLogoutCounter)
}

// LogoutBeforeCounter returns a count of UserServiceMock.Logout invocations
func (mmLogout *UserServiceMock) LogoutBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogout.beforeLogoutCounter)
}

// Calls returns a list of arguments used in each call to UserServiceMock.Logout.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLogout *mUserServiceMockLogout) Calls() []*UserServiceMockLogoutParams {
	mmLogout.mutex.RLock()

	argCopy := make([]*UserServiceMockLogoutParams, len(mmLogout.callArgs))
	copy(argCopy, mmLogout.callArgs)

	mmLogout.mutex.RUnlock()

	return argCopy
}

// MinimockLogoutDone returns true if the count of the Logout invocations corresponds
// the number of defined expectations
func (m *UserServiceMock) MinimockLogoutDone() bool {
	if m.LogoutMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LogoutMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LogoutMock.invocationsDone()
}

// MinimockLogoutInspect logs each unmet expectation
func (m *UserServiceMock) MinimockLogoutInspect() {
	for _, e := range m.LogoutMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserServiceMock.Logout with params: %#v", *e.params)
		}
	}

	afterLogoutCounter := mm_atomic.LoadUint64(&m.afterLogoutCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LogoutMock.defaultExpectation != nil && afterLogoutCounter < 1 {
		if m.LogoutMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserServiceMock.Logout")
		} else {
			m.t.Errorf("Expected call to UserServiceMock.Logout with params: %#v", *m.LogoutMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLogout != nil && afterLogoutCounter < 1 {
		m.t.Error("Expected call to UserServiceMock.Logout")
	}

	if !m.LogoutMock.invocationsDone() && afterLogoutCounter > 0 {
		m.t.Errorf("Expected %d calls to UserServiceMock.Logout but found %d calls",
			mm_atomic.LoadUint64(&m.LogoutMock.expectedInvocations), afterLogoutCounter)
	}
}

type mUserServiceMockRegistration struct {
	optional           bool
	mock               *UserServiceMock
	defaultExpectation *UserServiceMockRegistrationExpectation
	expectations       []*UserServiceMockRegistrationExpectation

	callArgs []*UserServiceMockRegistrationParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UserServiceMockRegistrationExpectation specifies expectation struct of the UserService.Registration
type UserServiceMockRegistrationExpectation struct {
	mock      *UserServiceMock
	params    *UserServiceMockRegistrationParams
	paramPtrs *UserServiceMockRegistrationParamPtrs
	results   *UserServiceMockRegistrationResults
	Counter   uint64
}

// UserServiceMockRegistrationParams contains parameters of the UserService.Registration
type UserServiceMockRegistrationParams struct {
	ctx    context.Context
	params model.RegistrationParams
}

// UserServiceMockRegistrationParamPtrs contains pointers to parameters of the UserService.Registration
type UserServiceMockRegistrationParamPtrs struct {
	ctx    *context.Context
	params *model.RegistrationParams
}

// UserServiceMockRegistrationResults contains results of the UserService.Registration
type UserServiceMockRegistrationResults struct {
	resp model.RegistrationResponse
	err  error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRegistration *mUserServiceMockRegistration) Optional() *mUserServiceMockRegistration {
	mmRegistration.optional = true
	return mmRegistration
}

// Expect sets up expected params for UserService.Registration
func (mmRegistration *mUserServiceMockRegistration) Expect(ctx context.Context, params model.RegistrationParams) *mUserServiceMockRegistration {
	if mmRegistration.mock.funcRegistration != nil {
		mmRegistration.mock.t.Fatalf("UserServiceMock.Registration mock is already set by Set")
	}

	if mmRegistration.defaultExpectation == nil {
		mmRegistration.defaultExpectation = &UserServiceMockRegistrationExpectation{}
	}

	if mmRegistration.defaultExpectation.paramPtrs != nil {
		mmRegistration.mock.t.Fatalf("UserServiceMock.Registration mock is already set by ExpectParams functions")
	}

	mmRegistration.defaultExpectation.params = &UserServiceMockRegistrationParams{ctx, params}
	for _, e := range mmRegistration.expectations {
		if minimock.Equal(e.params, mmRegistration.defaultExpectation.params) {
			mmRegistration.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRegistration.defaultExpectation.params)
		}
	}

	return mmRegistration
}

// ExpectCtxParam1 sets up expected param ctx for UserService.Registration
func (mmRegistration *mUserServiceMockRegistration) ExpectCtxParam1(ctx context.Context) *mUserServiceMockRegistration {
	if mmRegistration.mock.funcRegistration != nil {
		mmRegistration.mock.t.Fatalf("UserServiceMock.Registration mock is already set by Set")
	}

	if mmRegistration.defaultExpectation == nil {
		mmRegistration.defaultExpectation = &UserServiceMockRegistrationExpectation{}
	}

	if mmRegistration.defaultExpectation.params != nil {
		mmRegistration.mock.t.Fatalf("UserServiceMock.Registration mock is already set by Expect")
	}

	if mmRegistration.defaultExpectation.paramPtrs == nil {
		mmRegistration.defaultExpectation.paramPtrs = &UserServiceMockRegistrationParamPtrs{}
	}
	mmRegistration.defaultExpectation.paramPtrs.ctx = &ctx

	return mmRegistration
}

// ExpectParamsParam2 sets up expected param params for UserService.Registration
func (mmRegistration *mUserServiceMockRegistration) ExpectParamsParam2(params model.RegistrationParams) *mUserServiceMockRegistration {
	if mmRegistration.mock.funcRegistration != nil {
		mmRegistration.mock.t.Fatalf("UserServiceMock.Registration mock is already set by Set")
	}

	if mmRegistration.defaultExpectation == nil {
		mmRegistration.defaultExpectation = &UserServiceMockRegistrationExpectation{}
	}

	if mmRegistration.defaultExpectation.params != nil {
		mmRegistration.mock.t.Fatalf("UserServiceMock.Registration mock is already set by Expect")
	}

	if mmRegistration.defaultExpectation.paramPtrs == nil {
		mmRegistration.defaultExpectation.paramPtrs = &UserServiceMockRegistrationParamPtrs{}
	}
	mmRegistration.defaultExpectation.paramPtrs.params = &params

	return mmRegistration
}

// Inspect accepts an inspector function that has same arguments as the UserService.Registration
func (mmRegistration *mUserServiceMockRegistration) Inspect(f func(ctx context.Context, params model.RegistrationParams)) *mUserServiceMockRegistration {
	if mmRegistration.mock.inspectFuncRegistration != nil {
		mmRegistration.mock.t.Fatalf("Inspect function is already set for UserServiceMock.Registration")
	}

	mmRegistration.mock.inspectFuncRegistration = f

	return mmRegistration
}

// Return sets up results that will be returned by UserService.Registration
func (mmRegistration *mUserServiceMockRegistration) Return(resp model.RegistrationResponse, err error) *UserServiceMock {
	if mmRegistration.mock.funcRegistration != nil {
		mmRegistration.mock.t.Fatalf("UserServiceMock.Registration mock is already set by Set")
	}

	if mmRegistration.defaultExpectation == nil {
		mmRegistration.defaultExpectation = &UserServiceMockRegistrationExpectation{mock: mmRegistration.mock}
	}
	mmRegistration.defaultExpectation.results = &UserServiceMockRegistrationResults{resp, err}
	return mmRegistration.mock
}

// Set uses given function f to mock the UserService.Registration method
func (mmRegistration *mUserServiceMockRegistration) Set(f func(ctx context.Context, params model.RegistrationParams) (resp model.RegistrationResponse, err error)) *UserServiceMock {
	if mmRegistration.defaultExpectation != nil {
		mmRegistration.mock.t.Fatalf("Default expectation is already set for the UserService.Registration method")
	}

	if len(mmRegistration.expectations) > 0 {
		mmRegistration.mock.t.Fatalf("Some expectations are already set for the UserService.Registration method")
	}

	mmRegistration.mock.funcRegistration = f
	return mmRegistration.mock
}

// When sets expectation for the UserService.Registration which will trigger the result defined by the following
// Then helper
func (mmRegistration *mUserServiceMockRegistration) When(ctx context.Context, params model.RegistrationParams) *UserServiceMockRegistrationExpectation {
	if mmRegistration.mock.funcRegistration != nil {
		mmRegistration.mock.t.Fatalf("UserServiceMock.Registration mock is already set by Set")
	}

	expectation := &UserServiceMockRegistrationExpectation{
		mock:   mmRegistration.mock,
		params: &UserServiceMockRegistrationParams{ctx, params},
	}
	mmRegistration.expectations = append(mmRegistration.expectations, expectation)
	return expectation
}

// Then sets up UserService.Registration return parameters for the expectation previously defined by the When method
func (e *UserServiceMockRegistrationExpectation) Then(resp model.RegistrationResponse, err error) *UserServiceMock {
	e.results = &UserServiceMockRegistrationResults{resp, err}
	return e.mock
}

// Times sets number of times UserService.Registration should be invoked
func (mmRegistration *mUserServiceMockRegistration) Times(n uint64) *mUserServiceMockRegistration {
	if n == 0 {
		mmRegistration.mock.t.Fatalf("Times of UserServiceMock.Registration mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRegistration.expectedInvocations, n)
	return mmRegistration
}

func (mmRegistration *mUserServiceMockRegistration) invocationsDone() bool {
	if len(mmRegistration.expectations) == 0 && mmRegistration.defaultExpectation == nil && mmRegistration.mock.funcRegistration == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRegistration.mock.afterRegistrationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRegistration.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Registration implements service.UserService
func (mmRegistration *UserServiceMock) Registration(ctx context.Context, params model.RegistrationParams) (resp model.RegistrationResponse, err error) {
	mm_atomic.AddUint64(&mmRegistration.beforeRegistrationCounter, 1)
	defer mm_atomic.AddUint64(&mmRegistration.afterRegistrationCounter, 1)

	if mmRegistration.inspectFuncRegistration != nil {
		mmRegistration.inspectFuncRegistration(ctx, params)
	}

	mm_params := UserServiceMockRegistrationParams{ctx, params}

	// Record call args
	mmRegistration.RegistrationMock.mutex.Lock()
	mmRegistration.RegistrationMock.callArgs = append(mmRegistration.RegistrationMock.callArgs, &mm_params)
	mmRegistration.RegistrationMock.mutex.Unlock()

	for _, e := range mmRegistration.RegistrationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.resp, e.results.err
		}
	}

	if mmRegistration.RegistrationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegistration.RegistrationMock.defaultExpectation.Counter, 1)
		mm_want := mmRegistration.RegistrationMock.defaultExpectation.params
		mm_want_ptrs := mmRegistration.RegistrationMock.defaultExpectation.paramPtrs

		mm_got := UserServiceMockRegistrationParams{ctx, params}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRegistration.t.Errorf("UserServiceMock.Registration got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.params != nil && !minimock.Equal(*mm_want_ptrs.params, mm_got.params) {
				mmRegistration.t.Errorf("UserServiceMock.Registration got unexpected parameter params, want: %#v, got: %#v%s\n", *mm_want_ptrs.params, mm_got.params, minimock.Diff(*mm_want_ptrs.params, mm_got.params))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRegistration.t.Errorf("UserServiceMock.Registration got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRegistration.RegistrationMock.defaultExpectation.results
		if mm_results == nil {
			mmRegistration.t.Fatal("No results are set for the UserServiceMock.Registration")
		}
		return (*mm_results).resp, (*mm_results).err
	}
	if mmRegistration.funcRegistration != nil {
		return mmRegistration.funcRegistration(ctx, params)
	}
	mmRegistration.t.Fatalf("Unexpected call to UserServiceMock.Registration. %v %v", ctx, params)
	return
}

// RegistrationAfterCounter returns a count of finished UserServiceMock.Registration invocations
func (mmRegistration *UserServiceMock) RegistrationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegistration.afterRegistrationCounter)
}

// RegistrationBeforeCounter returns a count of UserServiceMock.Registration invocations
func (mmRegistration *UserServiceMock) RegistrationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegistration.beforeRegistrationCounter)
}

// Calls returns a list of arguments used in each call to UserServiceMock.Registration.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRegistration *mUserServiceMockRegistration) Calls() []*UserServiceMockRegistrationParams {
	mmRegistration.mutex.RLock()

	argCopy := make([]*UserServiceMockRegistrationParams, len(mmRegistration.callArgs))
	copy(argCopy, mmRegistration.callArgs)

	mmRegistration.mutex.RUnlock()

	return argCopy
}

// MinimockRegistrationDone returns true if the count of the Registration invocations corresponds
// the number of defined expectations
func (m *UserServiceMock) MinimockRegistrationDone() bool {
	if m.RegistrationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RegistrationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RegistrationMock.invocationsDone()
}

// MinimockRegistrationInspect logs each unmet expectation
func (m *UserServiceMock) MinimockRegistrationInspect() {
	for _, e := range m.RegistrationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserServiceMock.Registration with params: %#v", *e.params)
		}
	}

	afterRegistrationCounter := mm_atomic.LoadUint64(&m.afterRegistrationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RegistrationMock.defaultExpectation != nil && afterRegistrationCounter < 1 {
		if m.RegistrationMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserServiceMock.Registration")
		} else {
			m.t.Errorf("Expected call to UserServiceMock.Registration with params: %#v", *m.RegistrationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegistration != nil && afterRegistrationCounter < 1 {
		m.t.Error("Expected call to UserServiceMock.Registration")
	}

	if !m.RegistrationMock.invocationsDone() && afterRegistrationCounter > 0 {
		m.t.Errorf("Expected %d calls to UserServiceMock.Registration but found %d calls",
			mm_atomic.LoadUint64(&m.RegistrationMock.expectedInvocations), afterRegistrationCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UserServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetAccessTokenInspect()

			m.MinimockGetRefreshTokenInspect()

			m.MinimockLoginInspect()

			m.MinimockLogoutInspect()

			m.MinimockRegistrationInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UserServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UserServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetAccessTokenDone() &&
		m.MinimockGetRefreshTokenDone() &&
		m.MinimockLoginDone() &&
		m.MinimockLogoutDone() &&
		m.MinimockRegistrationDone()
}
