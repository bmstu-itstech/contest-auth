// Code generated by http://github.com/gojuno/minimock (v3.3.14). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/bmstu-itstech/contest-auth/internal/repository.UserRepository -o user_repository_minimock.go -n UserRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/bmstu-itstech/contest-auth/internal/model"
	"github.com/gojuno/minimock/v3"
)

// UserRepositoryMock implements repository.UserRepository
type UserRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateUser          func(ctx context.Context, params model.CreateUserParams) (resp model.CreateUserResponse, err error)
	inspectFuncCreateUser   func(ctx context.Context, params model.CreateUserParams)
	afterCreateUserCounter  uint64
	beforeCreateUserCounter uint64
	CreateUserMock          mUserRepositoryMockCreateUser

	funcGetUserByEmail          func(ctx context.Context, params model.GetUserByEmailParams) (resp model.GetUserByEmailResponse, err error)
	inspectFuncGetUserByEmail   func(ctx context.Context, params model.GetUserByEmailParams)
	afterGetUserByEmailCounter  uint64
	beforeGetUserByEmailCounter uint64
	GetUserByEmailMock          mUserRepositoryMockGetUserByEmail
}

// NewUserRepositoryMock returns a mock for repository.UserRepository
func NewUserRepositoryMock(t minimock.Tester) *UserRepositoryMock {
	m := &UserRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateUserMock = mUserRepositoryMockCreateUser{mock: m}
	m.CreateUserMock.callArgs = []*UserRepositoryMockCreateUserParams{}

	m.GetUserByEmailMock = mUserRepositoryMockGetUserByEmail{mock: m}
	m.GetUserByEmailMock.callArgs = []*UserRepositoryMockGetUserByEmailParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mUserRepositoryMockCreateUser struct {
	optional           bool
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockCreateUserExpectation
	expectations       []*UserRepositoryMockCreateUserExpectation

	callArgs []*UserRepositoryMockCreateUserParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UserRepositoryMockCreateUserExpectation specifies expectation struct of the UserRepository.CreateUser
type UserRepositoryMockCreateUserExpectation struct {
	mock      *UserRepositoryMock
	params    *UserRepositoryMockCreateUserParams
	paramPtrs *UserRepositoryMockCreateUserParamPtrs
	results   *UserRepositoryMockCreateUserResults
	Counter   uint64
}

// UserRepositoryMockCreateUserParams contains parameters of the UserRepository.CreateUser
type UserRepositoryMockCreateUserParams struct {
	ctx    context.Context
	params model.CreateUserParams
}

// UserRepositoryMockCreateUserParamPtrs contains pointers to parameters of the UserRepository.CreateUser
type UserRepositoryMockCreateUserParamPtrs struct {
	ctx    *context.Context
	params *model.CreateUserParams
}

// UserRepositoryMockCreateUserResults contains results of the UserRepository.CreateUser
type UserRepositoryMockCreateUserResults struct {
	resp model.CreateUserResponse
	err  error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateUser *mUserRepositoryMockCreateUser) Optional() *mUserRepositoryMockCreateUser {
	mmCreateUser.optional = true
	return mmCreateUser
}

// Expect sets up expected params for UserRepository.CreateUser
func (mmCreateUser *mUserRepositoryMockCreateUser) Expect(ctx context.Context, params model.CreateUserParams) *mUserRepositoryMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserRepositoryMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.paramPtrs != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryMock.CreateUser mock is already set by ExpectParams functions")
	}

	mmCreateUser.defaultExpectation.params = &UserRepositoryMockCreateUserParams{ctx, params}
	for _, e := range mmCreateUser.expectations {
		if minimock.Equal(e.params, mmCreateUser.defaultExpectation.params) {
			mmCreateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUser.defaultExpectation.params)
		}
	}

	return mmCreateUser
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.CreateUser
func (mmCreateUser *mUserRepositoryMockCreateUser) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserRepositoryMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &UserRepositoryMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateUser
}

// ExpectParamsParam2 sets up expected param params for UserRepository.CreateUser
func (mmCreateUser *mUserRepositoryMockCreateUser) ExpectParamsParam2(params model.CreateUserParams) *mUserRepositoryMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserRepositoryMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &UserRepositoryMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.params = &params

	return mmCreateUser
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.CreateUser
func (mmCreateUser *mUserRepositoryMockCreateUser) Inspect(f func(ctx context.Context, params model.CreateUserParams)) *mUserRepositoryMockCreateUser {
	if mmCreateUser.mock.inspectFuncCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.CreateUser")
	}

	mmCreateUser.mock.inspectFuncCreateUser = f

	return mmCreateUser
}

// Return sets up results that will be returned by UserRepository.CreateUser
func (mmCreateUser *mUserRepositoryMockCreateUser) Return(resp model.CreateUserResponse, err error) *UserRepositoryMock {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserRepositoryMockCreateUserExpectation{mock: mmCreateUser.mock}
	}
	mmCreateUser.defaultExpectation.results = &UserRepositoryMockCreateUserResults{resp, err}
	return mmCreateUser.mock
}

// Set uses given function f to mock the UserRepository.CreateUser method
func (mmCreateUser *mUserRepositoryMockCreateUser) Set(f func(ctx context.Context, params model.CreateUserParams) (resp model.CreateUserResponse, err error)) *UserRepositoryMock {
	if mmCreateUser.defaultExpectation != nil {
		mmCreateUser.mock.t.Fatalf("Default expectation is already set for the UserRepository.CreateUser method")
	}

	if len(mmCreateUser.expectations) > 0 {
		mmCreateUser.mock.t.Fatalf("Some expectations are already set for the UserRepository.CreateUser method")
	}

	mmCreateUser.mock.funcCreateUser = f
	return mmCreateUser.mock
}

// When sets expectation for the UserRepository.CreateUser which will trigger the result defined by the following
// Then helper
func (mmCreateUser *mUserRepositoryMockCreateUser) When(ctx context.Context, params model.CreateUserParams) *UserRepositoryMockCreateUserExpectation {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryMock.CreateUser mock is already set by Set")
	}

	expectation := &UserRepositoryMockCreateUserExpectation{
		mock:   mmCreateUser.mock,
		params: &UserRepositoryMockCreateUserParams{ctx, params},
	}
	mmCreateUser.expectations = append(mmCreateUser.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.CreateUser return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockCreateUserExpectation) Then(resp model.CreateUserResponse, err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockCreateUserResults{resp, err}
	return e.mock
}

// Times sets number of times UserRepository.CreateUser should be invoked
func (mmCreateUser *mUserRepositoryMockCreateUser) Times(n uint64) *mUserRepositoryMockCreateUser {
	if n == 0 {
		mmCreateUser.mock.t.Fatalf("Times of UserRepositoryMock.CreateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateUser.expectedInvocations, n)
	return mmCreateUser
}

func (mmCreateUser *mUserRepositoryMockCreateUser) invocationsDone() bool {
	if len(mmCreateUser.expectations) == 0 && mmCreateUser.defaultExpectation == nil && mmCreateUser.mock.funcCreateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateUser.mock.afterCreateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateUser implements repository.UserRepository
func (mmCreateUser *UserRepositoryMock) CreateUser(ctx context.Context, params model.CreateUserParams) (resp model.CreateUserResponse, err error) {
	mm_atomic.AddUint64(&mmCreateUser.beforeCreateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateUser.afterCreateUserCounter, 1)

	if mmCreateUser.inspectFuncCreateUser != nil {
		mmCreateUser.inspectFuncCreateUser(ctx, params)
	}

	mm_params := UserRepositoryMockCreateUserParams{ctx, params}

	// Record call args
	mmCreateUser.CreateUserMock.mutex.Lock()
	mmCreateUser.CreateUserMock.callArgs = append(mmCreateUser.CreateUserMock.callArgs, &mm_params)
	mmCreateUser.CreateUserMock.mutex.Unlock()

	for _, e := range mmCreateUser.CreateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.resp, e.results.err
		}
	}

	if mmCreateUser.CreateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateUser.CreateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateUser.CreateUserMock.defaultExpectation.params
		mm_want_ptrs := mmCreateUser.CreateUserMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryMockCreateUserParams{ctx, params}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateUser.t.Errorf("UserRepositoryMock.CreateUser got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.params != nil && !minimock.Equal(*mm_want_ptrs.params, mm_got.params) {
				mmCreateUser.t.Errorf("UserRepositoryMock.CreateUser got unexpected parameter params, want: %#v, got: %#v%s\n", *mm_want_ptrs.params, mm_got.params, minimock.Diff(*mm_want_ptrs.params, mm_got.params))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateUser.t.Errorf("UserRepositoryMock.CreateUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateUser.CreateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateUser.t.Fatal("No results are set for the UserRepositoryMock.CreateUser")
		}
		return (*mm_results).resp, (*mm_results).err
	}
	if mmCreateUser.funcCreateUser != nil {
		return mmCreateUser.funcCreateUser(ctx, params)
	}
	mmCreateUser.t.Fatalf("Unexpected call to UserRepositoryMock.CreateUser. %v %v", ctx, params)
	return
}

// CreateUserAfterCounter returns a count of finished UserRepositoryMock.CreateUser invocations
func (mmCreateUser *UserRepositoryMock) CreateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.afterCreateUserCounter)
}

// CreateUserBeforeCounter returns a count of UserRepositoryMock.CreateUser invocations
func (mmCreateUser *UserRepositoryMock) CreateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.beforeCreateUserCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.CreateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUser *mUserRepositoryMockCreateUser) Calls() []*UserRepositoryMockCreateUserParams {
	mmCreateUser.mutex.RLock()

	argCopy := make([]*UserRepositoryMockCreateUserParams, len(mmCreateUser.callArgs))
	copy(argCopy, mmCreateUser.callArgs)

	mmCreateUser.mutex.RUnlock()

	return argCopy
}

// MinimockCreateUserDone returns true if the count of the CreateUser invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockCreateUserDone() bool {
	if m.CreateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateUserMock.invocationsDone()
}

// MinimockCreateUserInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockCreateUserInspect() {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.CreateUser with params: %#v", *e.params)
		}
	}

	afterCreateUserCounter := mm_atomic.LoadUint64(&m.afterCreateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && afterCreateUserCounter < 1 {
		if m.CreateUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserRepositoryMock.CreateUser")
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.CreateUser with params: %#v", *m.CreateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && afterCreateUserCounter < 1 {
		m.t.Error("Expected call to UserRepositoryMock.CreateUser")
	}

	if !m.CreateUserMock.invocationsDone() && afterCreateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryMock.CreateUser but found %d calls",
			mm_atomic.LoadUint64(&m.CreateUserMock.expectedInvocations), afterCreateUserCounter)
	}
}

type mUserRepositoryMockGetUserByEmail struct {
	optional           bool
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockGetUserByEmailExpectation
	expectations       []*UserRepositoryMockGetUserByEmailExpectation

	callArgs []*UserRepositoryMockGetUserByEmailParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UserRepositoryMockGetUserByEmailExpectation specifies expectation struct of the UserRepository.GetUserByEmail
type UserRepositoryMockGetUserByEmailExpectation struct {
	mock      *UserRepositoryMock
	params    *UserRepositoryMockGetUserByEmailParams
	paramPtrs *UserRepositoryMockGetUserByEmailParamPtrs
	results   *UserRepositoryMockGetUserByEmailResults
	Counter   uint64
}

// UserRepositoryMockGetUserByEmailParams contains parameters of the UserRepository.GetUserByEmail
type UserRepositoryMockGetUserByEmailParams struct {
	ctx    context.Context
	params model.GetUserByEmailParams
}

// UserRepositoryMockGetUserByEmailParamPtrs contains pointers to parameters of the UserRepository.GetUserByEmail
type UserRepositoryMockGetUserByEmailParamPtrs struct {
	ctx    *context.Context
	params *model.GetUserByEmailParams
}

// UserRepositoryMockGetUserByEmailResults contains results of the UserRepository.GetUserByEmail
type UserRepositoryMockGetUserByEmailResults struct {
	resp model.GetUserByEmailResponse
	err  error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUserByEmail *mUserRepositoryMockGetUserByEmail) Optional() *mUserRepositoryMockGetUserByEmail {
	mmGetUserByEmail.optional = true
	return mmGetUserByEmail
}

// Expect sets up expected params for UserRepository.GetUserByEmail
func (mmGetUserByEmail *mUserRepositoryMockGetUserByEmail) Expect(ctx context.Context, params model.GetUserByEmailParams) *mUserRepositoryMockGetUserByEmail {
	if mmGetUserByEmail.mock.funcGetUserByEmail != nil {
		mmGetUserByEmail.mock.t.Fatalf("UserRepositoryMock.GetUserByEmail mock is already set by Set")
	}

	if mmGetUserByEmail.defaultExpectation == nil {
		mmGetUserByEmail.defaultExpectation = &UserRepositoryMockGetUserByEmailExpectation{}
	}

	if mmGetUserByEmail.defaultExpectation.paramPtrs != nil {
		mmGetUserByEmail.mock.t.Fatalf("UserRepositoryMock.GetUserByEmail mock is already set by ExpectParams functions")
	}

	mmGetUserByEmail.defaultExpectation.params = &UserRepositoryMockGetUserByEmailParams{ctx, params}
	for _, e := range mmGetUserByEmail.expectations {
		if minimock.Equal(e.params, mmGetUserByEmail.defaultExpectation.params) {
			mmGetUserByEmail.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserByEmail.defaultExpectation.params)
		}
	}

	return mmGetUserByEmail
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.GetUserByEmail
func (mmGetUserByEmail *mUserRepositoryMockGetUserByEmail) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockGetUserByEmail {
	if mmGetUserByEmail.mock.funcGetUserByEmail != nil {
		mmGetUserByEmail.mock.t.Fatalf("UserRepositoryMock.GetUserByEmail mock is already set by Set")
	}

	if mmGetUserByEmail.defaultExpectation == nil {
		mmGetUserByEmail.defaultExpectation = &UserRepositoryMockGetUserByEmailExpectation{}
	}

	if mmGetUserByEmail.defaultExpectation.params != nil {
		mmGetUserByEmail.mock.t.Fatalf("UserRepositoryMock.GetUserByEmail mock is already set by Expect")
	}

	if mmGetUserByEmail.defaultExpectation.paramPtrs == nil {
		mmGetUserByEmail.defaultExpectation.paramPtrs = &UserRepositoryMockGetUserByEmailParamPtrs{}
	}
	mmGetUserByEmail.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetUserByEmail
}

// ExpectParamsParam2 sets up expected param params for UserRepository.GetUserByEmail
func (mmGetUserByEmail *mUserRepositoryMockGetUserByEmail) ExpectParamsParam2(params model.GetUserByEmailParams) *mUserRepositoryMockGetUserByEmail {
	if mmGetUserByEmail.mock.funcGetUserByEmail != nil {
		mmGetUserByEmail.mock.t.Fatalf("UserRepositoryMock.GetUserByEmail mock is already set by Set")
	}

	if mmGetUserByEmail.defaultExpectation == nil {
		mmGetUserByEmail.defaultExpectation = &UserRepositoryMockGetUserByEmailExpectation{}
	}

	if mmGetUserByEmail.defaultExpectation.params != nil {
		mmGetUserByEmail.mock.t.Fatalf("UserRepositoryMock.GetUserByEmail mock is already set by Expect")
	}

	if mmGetUserByEmail.defaultExpectation.paramPtrs == nil {
		mmGetUserByEmail.defaultExpectation.paramPtrs = &UserRepositoryMockGetUserByEmailParamPtrs{}
	}
	mmGetUserByEmail.defaultExpectation.paramPtrs.params = &params

	return mmGetUserByEmail
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.GetUserByEmail
func (mmGetUserByEmail *mUserRepositoryMockGetUserByEmail) Inspect(f func(ctx context.Context, params model.GetUserByEmailParams)) *mUserRepositoryMockGetUserByEmail {
	if mmGetUserByEmail.mock.inspectFuncGetUserByEmail != nil {
		mmGetUserByEmail.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.GetUserByEmail")
	}

	mmGetUserByEmail.mock.inspectFuncGetUserByEmail = f

	return mmGetUserByEmail
}

// Return sets up results that will be returned by UserRepository.GetUserByEmail
func (mmGetUserByEmail *mUserRepositoryMockGetUserByEmail) Return(resp model.GetUserByEmailResponse, err error) *UserRepositoryMock {
	if mmGetUserByEmail.mock.funcGetUserByEmail != nil {
		mmGetUserByEmail.mock.t.Fatalf("UserRepositoryMock.GetUserByEmail mock is already set by Set")
	}

	if mmGetUserByEmail.defaultExpectation == nil {
		mmGetUserByEmail.defaultExpectation = &UserRepositoryMockGetUserByEmailExpectation{mock: mmGetUserByEmail.mock}
	}
	mmGetUserByEmail.defaultExpectation.results = &UserRepositoryMockGetUserByEmailResults{resp, err}
	return mmGetUserByEmail.mock
}

// Set uses given function f to mock the UserRepository.GetUserByEmail method
func (mmGetUserByEmail *mUserRepositoryMockGetUserByEmail) Set(f func(ctx context.Context, params model.GetUserByEmailParams) (resp model.GetUserByEmailResponse, err error)) *UserRepositoryMock {
	if mmGetUserByEmail.defaultExpectation != nil {
		mmGetUserByEmail.mock.t.Fatalf("Default expectation is already set for the UserRepository.GetUserByEmail method")
	}

	if len(mmGetUserByEmail.expectations) > 0 {
		mmGetUserByEmail.mock.t.Fatalf("Some expectations are already set for the UserRepository.GetUserByEmail method")
	}

	mmGetUserByEmail.mock.funcGetUserByEmail = f
	return mmGetUserByEmail.mock
}

// When sets expectation for the UserRepository.GetUserByEmail which will trigger the result defined by the following
// Then helper
func (mmGetUserByEmail *mUserRepositoryMockGetUserByEmail) When(ctx context.Context, params model.GetUserByEmailParams) *UserRepositoryMockGetUserByEmailExpectation {
	if mmGetUserByEmail.mock.funcGetUserByEmail != nil {
		mmGetUserByEmail.mock.t.Fatalf("UserRepositoryMock.GetUserByEmail mock is already set by Set")
	}

	expectation := &UserRepositoryMockGetUserByEmailExpectation{
		mock:   mmGetUserByEmail.mock,
		params: &UserRepositoryMockGetUserByEmailParams{ctx, params},
	}
	mmGetUserByEmail.expectations = append(mmGetUserByEmail.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.GetUserByEmail return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockGetUserByEmailExpectation) Then(resp model.GetUserByEmailResponse, err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockGetUserByEmailResults{resp, err}
	return e.mock
}

// Times sets number of times UserRepository.GetUserByEmail should be invoked
func (mmGetUserByEmail *mUserRepositoryMockGetUserByEmail) Times(n uint64) *mUserRepositoryMockGetUserByEmail {
	if n == 0 {
		mmGetUserByEmail.mock.t.Fatalf("Times of UserRepositoryMock.GetUserByEmail mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUserByEmail.expectedInvocations, n)
	return mmGetUserByEmail
}

func (mmGetUserByEmail *mUserRepositoryMockGetUserByEmail) invocationsDone() bool {
	if len(mmGetUserByEmail.expectations) == 0 && mmGetUserByEmail.defaultExpectation == nil && mmGetUserByEmail.mock.funcGetUserByEmail == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUserByEmail.mock.afterGetUserByEmailCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUserByEmail.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUserByEmail implements repository.UserRepository
func (mmGetUserByEmail *UserRepositoryMock) GetUserByEmail(ctx context.Context, params model.GetUserByEmailParams) (resp model.GetUserByEmailResponse, err error) {
	mm_atomic.AddUint64(&mmGetUserByEmail.beforeGetUserByEmailCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserByEmail.afterGetUserByEmailCounter, 1)

	if mmGetUserByEmail.inspectFuncGetUserByEmail != nil {
		mmGetUserByEmail.inspectFuncGetUserByEmail(ctx, params)
	}

	mm_params := UserRepositoryMockGetUserByEmailParams{ctx, params}

	// Record call args
	mmGetUserByEmail.GetUserByEmailMock.mutex.Lock()
	mmGetUserByEmail.GetUserByEmailMock.callArgs = append(mmGetUserByEmail.GetUserByEmailMock.callArgs, &mm_params)
	mmGetUserByEmail.GetUserByEmailMock.mutex.Unlock()

	for _, e := range mmGetUserByEmail.GetUserByEmailMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.resp, e.results.err
		}
	}

	if mmGetUserByEmail.GetUserByEmailMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserByEmail.GetUserByEmailMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserByEmail.GetUserByEmailMock.defaultExpectation.params
		mm_want_ptrs := mmGetUserByEmail.GetUserByEmailMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryMockGetUserByEmailParams{ctx, params}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUserByEmail.t.Errorf("UserRepositoryMock.GetUserByEmail got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.params != nil && !minimock.Equal(*mm_want_ptrs.params, mm_got.params) {
				mmGetUserByEmail.t.Errorf("UserRepositoryMock.GetUserByEmail got unexpected parameter params, want: %#v, got: %#v%s\n", *mm_want_ptrs.params, mm_got.params, minimock.Diff(*mm_want_ptrs.params, mm_got.params))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserByEmail.t.Errorf("UserRepositoryMock.GetUserByEmail got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserByEmail.GetUserByEmailMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserByEmail.t.Fatal("No results are set for the UserRepositoryMock.GetUserByEmail")
		}
		return (*mm_results).resp, (*mm_results).err
	}
	if mmGetUserByEmail.funcGetUserByEmail != nil {
		return mmGetUserByEmail.funcGetUserByEmail(ctx, params)
	}
	mmGetUserByEmail.t.Fatalf("Unexpected call to UserRepositoryMock.GetUserByEmail. %v %v", ctx, params)
	return
}

// GetUserByEmailAfterCounter returns a count of finished UserRepositoryMock.GetUserByEmail invocations
func (mmGetUserByEmail *UserRepositoryMock) GetUserByEmailAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByEmail.afterGetUserByEmailCounter)
}

// GetUserByEmailBeforeCounter returns a count of UserRepositoryMock.GetUserByEmail invocations
func (mmGetUserByEmail *UserRepositoryMock) GetUserByEmailBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByEmail.beforeGetUserByEmailCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.GetUserByEmail.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserByEmail *mUserRepositoryMockGetUserByEmail) Calls() []*UserRepositoryMockGetUserByEmailParams {
	mmGetUserByEmail.mutex.RLock()

	argCopy := make([]*UserRepositoryMockGetUserByEmailParams, len(mmGetUserByEmail.callArgs))
	copy(argCopy, mmGetUserByEmail.callArgs)

	mmGetUserByEmail.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserByEmailDone returns true if the count of the GetUserByEmail invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockGetUserByEmailDone() bool {
	if m.GetUserByEmailMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserByEmailMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserByEmailMock.invocationsDone()
}

// MinimockGetUserByEmailInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockGetUserByEmailInspect() {
	for _, e := range m.GetUserByEmailMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.GetUserByEmail with params: %#v", *e.params)
		}
	}

	afterGetUserByEmailCounter := mm_atomic.LoadUint64(&m.afterGetUserByEmailCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserByEmailMock.defaultExpectation != nil && afterGetUserByEmailCounter < 1 {
		if m.GetUserByEmailMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserRepositoryMock.GetUserByEmail")
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.GetUserByEmail with params: %#v", *m.GetUserByEmailMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserByEmail != nil && afterGetUserByEmailCounter < 1 {
		m.t.Error("Expected call to UserRepositoryMock.GetUserByEmail")
	}

	if !m.GetUserByEmailMock.invocationsDone() && afterGetUserByEmailCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryMock.GetUserByEmail but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserByEmailMock.expectedInvocations), afterGetUserByEmailCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UserRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateUserInspect()

			m.MinimockGetUserByEmailInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UserRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UserRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateUserDone() &&
		m.MinimockGetUserByEmailDone()
}
